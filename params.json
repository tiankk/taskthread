{"name":"TaskThread","tagline":"A c++ library for multi-threads programming on windows platform.","body":"## Introduction\r\nTaskThread is a c++ library for multi-threads programming on windows(xp+) platform.\r\n\r\n## Features\r\n* Well wrapped interface.\r\n* Well memory management.\r\n* Integrate with UI thread easily.\r\n* Based on IOCP.\r\n* Task cancel support.\r\n\r\n## How to use\r\n### General\r\n1. Add TaskThread Project to your solution.\r\n2. Include `src/task_thread_export.h`.\r\n3. Modify `tthread::THREAD_ID` enum in `src/const_define.h` to add new static thread id.  \r\n\tSample:   \r\n\tOriginal enum:   \t\r\n\t```cpp\r\n\tnamespace tthread\r\n\t{\r\n\t\tenum THREAD_ID\r\n\t\t{\r\n\t\t\tSTATIC_THREAD_START,  // add static thread id below\r\n\t\t\tDEFAULT,\r\n\t\t\tSTATIC_THREAD_END, // add static thread id above\r\n\t\t\tRUNONCE = 1024\r\n\t\t};\r\n\t}\r\n\t```\r\n\tAdd `USER_DEF`:\r\n\t```cpp\r\n\tnamespace tthread\r\n\t{\r\n\t\tenum THREAD_ID\r\n\t\t{\r\n\t\t\tSTATIC_THREAD_START,  // add static thread id below\r\n\t\t\tDEFAULT,\r\n\t\t\tUSER_DEF,\r\n\t\t\tSTATIC_THREAD_END, // add static thread id above\r\n\t\t\tRUNONCE = 1024\r\n\t\t};\r\n\t}\r\n\t```\r\n\r\n4. Call `tthread::AsyncTask()`.\r\n\t1. Pass your function/method to `tthread::Bind()`, build task object for task parameter of `tthread::AsyncTask()`.\r\n\t2. Set another parameters if necessary. For instance, thread id parameter decide which thread will be run the task. You have defined one or more in step 3. \r\n5. Build and run your exe. The function/method you passed to the `tthread::Bind()` will be run in the static thread referenced by thread id you have defined and passed to.\r\n\r\n### `tthread::Bind()`\r\n1. This Bind() function comes from chromium.\r\n2. The max number of parameters is **7**.\r\n3. Declaring `tthread::utility::Callback<>` or `tthread::utility::Closure` to get return value is no necessary generally. Just pass `tthread::Bind()` to `tthread::AsyncTask()` or `tthread::SyncTask()` as one parameter directly. In general, namespace `tthread::utility` is not used.\r\n\r\nSample:   \r\n* Bind function:   \r\n\r\n\t```cpp\r\n\tint Return5()\r\n\t{\r\n\t\treturn 5;\r\n\t}\r\n\t\r\n\ttthread::utility::Callback<int(void)> func_cb = tthread::Bind(&Return5);\r\n\tLOG(INFO) << func_cb.Run();  // Prints 5.\r\n\t\r\n\tvoid PrintHi()\r\n\t{\r\n\t\tLOG(INFO) << \"hi.\";\r\n\t}\r\n\t\r\n\ttthread::utility::Closure void_func_cb = tthread::Bind(&PrintHi);\r\n\tvoid_func_cb.Run();  // Prints: hi.\r\n\t```\r\n\r\n* Bind method of reference-counted class:\r\n\t```cpp\r\n\tclass Ref : public tthread::RefCountedThreadSafe<Ref> {\r\n\tpublic:\r\n\t\tint Foo() { return 3; }\r\n\t\tvoid PrintBye() { LOG(INFO) << \"bye.\"; }\r\n\t};\r\n\t\r\n\ttthread::ScopedRefPtr<Ref> ref = new Ref();\r\n\ttthread::utility::Callback<int(void)> ref_cb = tthread::Bind(&Ref::Foo, ref.get());\r\n\tLOG(INFO) << ref_cb.Run();  // Prints out 3.\r\n\t\r\n\ttthread::utility::Closure void_ref_cb = tthread::Bind(&Ref::PrintBye, ref.get());\r\n\tvoid_ref_cb.Run();  // Prints: bye.\r\n\t```\r\n\r\n* Bind method:\r\n**WARNING**: Must be sure object's lifecycle is long enough to run its method. \r\n\t```cpp\r\n\tclass NoRef {\r\n\tpublic:\r\n\t\tint Foo() { return 4; }\r\n\t\tvoid PrintWhy() { LOG(INFO) << \"why???\"; }\r\n\t};\r\n\t\r\n\tNoRef no_ref;\r\n\ttthread::utility::Callback<int(void)> no_ref_cb = tthread::Bind(&NoRef::Foo, tthread::Unretained(&no_ref));\r\n\tLOG(INFO) << ref_cb.Run();  // Prints out 4.\r\n\t\r\n\ttthread::utility::Closure void_no_ref_cb = tthread::Bind(&NoRef::PrintWhy, tthread::Unretained(&no_ref));\r\n\tvoid_no_ref_cb.Run();  // Prints: why???\r\n\t```\r\n\r\n* Bind reference:\r\n\t```cpp\r\n\tint Identity(int n) { return n; }\r\n\tint value = 1;\r\n\ttthread::utility::Callback<int(void)> bound_copy_cb = tthread::Bind(&Identity, value);\r\n\ttthread::utility::Callback<int(void)> bound_ref_cb = tthread::Bind(&Identity, tthread::ConstRef(value));\r\n\tLOG(INFO) << bound_copy_cb.Run();  // Prints 1.\r\n\tLOG(INFO) << bound_ref_cb.Run();  // Prints 1.\r\n\t\r\n\tvalue = 2;\r\n\tLOG(INFO) << bound_copy_cb.Run();  // Prints 1.\r\n\tLOG(INFO) << bound_ref_cb.Run();  // Prints 2.\r\n\t```\r\n\r\n* Curry func:\r\n\t```cpp\r\n\tint Sum(int a, int b, int c)\r\n\t{\r\n\t\treturn a + b + c;\r\n\t}\r\n\t\r\n\ttthread::utility::Callback<int(int, int)> sum3_cb = tthread::Bind(&Sum, 3);\r\n\tLOG(INFO) << sum3_cb.Run(4, 5);  // Prints 12.\r\n\t\r\n\ttthread::utility::Callback<int(int)> sum7_cb = tthread::Bind(&Sum, 3, 4);\r\n\tLOG(INFO) << sum7_cb.Run(10);  // Prints 17.\r\n\t```\r\n\r\n### Asynchronous callback\r\n1. There are two callback type according to which thread will be run the callback function.\r\n\t1. If callback function run in **task thread**, you should derive from `tthread::IAsyncRunnableTaskCallback`.\r\n\t2. If callback funciton run in **UI thread**, you should derive form `tthread::IAsyncRunnableMsgCallback`.\r\n\t3. Implement `void OnAsyncComplete(ScopedRefPtr<ReturnValue> ret, const tstring& identifier)` function. `ret` is return value. And you can distinguish invoke point by `identifier`.   \r\n\t\r\n\tSample:   \r\n\t```cpp\r\n\tclass UserTaskCallBack : public tthread::IAysncRunnableTaskCallback\r\n\t{\r\n\tpublic:\r\n\t\tvoid OnAsyncComplete(ScopedRefPtr<ReturnValue> ret, const tstring& identifier)\r\n\t\t{\r\n\t\t\tif(identifier == _T(\"get_value\"))\r\n\t\t\t{\r\n\t\t\t\tif (ret->default_ret_ == 123)\r\n\t\t\t\t{\r\n\t\t\t\t\t// do something\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t```\r\n2. Wrap your function/method to support return value.\r\n\t1. The return type of the wrapped function is `void`.\r\n\t2. If function/method have many parameters, return value parameter **must be** the last one.\r\n\t3. The **max** number of parameters is **7**. But, **do not** forget that `this` pointer is the first parameter for method. So the max number of parameters for method is **6**.\r\n\t4. `tthread::ReturnValue` **should not** wrapped by `tthread::ScopedRefPtr`, if so, callback function running in UI thread may be crash.   \r\n\r\n\tSample:   \r\n\r\n\tOriginal function:\r\n\t```cpp\r\n\tint get_value()\r\n\t{\r\n\t\treturn 123;\r\n\t}\r\n\t```\r\n   \r\n\tWrapped function:\r\n\t```cpp\r\n\tvoid async_get_value(tthread::ReturnValue * ret)\r\n\t{\r\n\t\tret.default_ret_ = get_value();\r\n\t}\r\n\t```\r\n\r\n3. Build wrapped function `async_get_value` to task by `tthread::Bind()` and pass it to `thread::AsyncTask()`.  Also, pass callback object pointer or smart pointer object to `thread::AsyncTask()`.   \r\n\tSample:\r\n\t```cpp\r\n\ttthread::ScopedRetPtr<UserTaskCallBack> user_task_callback = new UserTaskCallBack;\r\n\t\r\n\t// some logic\r\n\t\r\n\ttthread::AsyncTask<tthread::ReturnValue>(_T(\"get_value\"), tthread::Bind(async_get_value), tthread::USER_DEF, user_task_callback.get());\r\n\t``` \r\n\r\n4. `tthread::IAsyncRunnableTaskCallback` support smart pointer, so it is safe after you call `tthread::AysncTask()`.\r\n5. `tthread::IAsyncRunnableMsgCallback` **does not** support smart pointer, so you should insure that callback object lifecycle is long enough until callback function is called. Why it does not support? Because this callback object is usually the main window object, tthread should not manage its lifecycle. Of course, if it is not the main window object, you can make it support smart pointer, just derived from `tthread::RefCountedThreadSafe`.\r\n\r\n### User-defined return value type\r\n1. Three return value types(ReturnValue/StringReturnValue/IntReturnValue) are already in library. See `src/return_value_type.h`   \r\n2. User can define new type by derived from `tthread::ReturnValue`.   \r\n\r\n\tSample:   \r\n\r\n\t```cpp\r\n\tstruct UserType\r\n\t{\r\n\t\t// some members\r\n\t};\r\n\r\n\tstruct UserTypeReturnValue : public tthread::ReturnValue\r\n\t{\r\n\t\tUserType user_;\r\n\t};\r\n\t```\r\n3. In wrapped function/method or callback function `OnAsyncComplete()`, you should cast `tthread::ReturnValue` pointer to `UserTypeReturnValue` pointer.   \r\n\r\n\tSample:   \r\n\r\n\t```cpp\r\n\tUserTypeReturnValue* p = static_cast<UserTypeReturnValue*>(ret.get());\r\n\t```\r\n4. When you call `tthread::Bind()`, you should **never** create `UserTypeReturnValue` object and pass the pointer to `tthread::Bind()`. TaskThread will create it automatically. Just like the sample below.\r\n   \r\n\tSample:\r\n\t```cpp\r\n\ttthread::Bind(async_get_value);\r\n\t```\r\n\r\n\r\n### User-defined context parameter type\r\n1. Sometimes, context parameters are stored for refering in callback function or using in whatever logic.   \r\n\tSample:   \r\n\tOne int value should be stored.   \r\n\t```cpp\r\n\tstruct IntReturnParam : public tthread::ReturnParam\r\n\t{\r\n\t\tint stored_int_;\r\n\t}\r\n\t```\r\n\r\n\tWrapped function:\r\n\t```cpp\r\n\tvoid async_get_value(tthread::ScopedRefPtr<tthread::ReturnParam> param, ReturnValue* ret)\r\n\t{\r\n\t\tret.param_ = param;\r\n\t\tret.default_ret_ = get_value();\r\n\t}\r\n\t```\r\n\r\n\tCall `tthread::AsyncTask()`:\r\n\t```cpp\r\n\ttthread::ScopedRetPtr<UserTaskCallBack> user_task_cb = new UserTaskCallBack;\r\n\r\n\t// some logic\r\n\r\n\tIntReturnParam* p = new IntReturnParam;\r\n\tp->stored_int_ = 1234;\r\n\ttthread::AsyncTask<UserTypeReturnValue>(_T(\"user_logic\"), tthread::Bind(aysnc_get_value, p), tthread::USER_DEF, user_task_cb.get());\r\n\t```\r\n\r\n\tUse context parameter in callback function:\r\n\t```cpp\r\n\tclass UserTaskCallBack : public tthread::IAysncRunnableTaskCallback\r\n\t{\r\n\tpublic:\r\n\t\tvoid OnAsyncComplete(ScopedRefPtr<ReturnValue> ret, const tstring& identifier)\r\n\t\t{\r\n\t\t\tif(identifier == _T(\"user_logic\"))\r\n\t\t\t{\r\n\t\t\t\tIntReturnParam* param = static_cast<IntReturnParam>(ret->param_.get())\r\n\t\t\t\tif (param->stored_int_ == 1234)\r\n\t\t\t\t{\r\n\t\t\t\t\t// some logic\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n2. Again, You should **never** create and pass the return value object pointer to `tthread::Bind()`.\r\n3. The context parameter pointer passed to `tthread::AysncTask()` will be recycle automatilcally. **Do not** delele it by yourself.\r\n\r\n### Integrate with UI thread\r\n1. As said in [Asynchronous callback](#Asynchronous callback), if callback class is derived from `tthread::IAsyncRunnableMsgCallback` and its instance is initiated in UI thread(main thread), callback function will run in UI thread(main thread).\r\n\tSample:\r\n\t```cpp\r\n\tclass UserMsgCallback : public tthread::IAsyncRunnableMsgCallback\r\n\t{\r\n\t\tvoid OnAsyncComplete(ScopedRefPtr<ReturnValue> ret, const tstring& identifier)\r\n\t\t{\r\n\t\t\t// some logic\r\n\t\t}\r\n\t}\r\n\t\r\n\t// some logic\r\n\t\r\n\tUserMsgCallback user_msg_callback; // in UI thread(main thread)\r\n\t\r\n\t// some logic\r\n\t\r\n\ttthread::AsyncTask<tthread::ReturnValue>(_T(\"get_value\"), tthread::Bind(async_get_value), tthread::USER_DEF, &user_msg_callback);\r\n\t\r\n\t```\r\nAgain, as said in [Asynchronous callback](#Asynchronous callback), `tthread::AsyncRunnableMsgCallback` **does not** support smart pointer, you should manage lifecycle of callback objcet and make sure it is exist when callback function is called.\r\n2. Also, you can use `tthread::AsyncMessage()` interface to send `tthread::ReturnValue` object or other user-defined return value object to the UI thread(main thread) directly, without triggering callback function by one task. The `tthread::ReturnValue` object here is just one message.\r\n\r\n### `tthread::RUNONCE` thread\r\n1. There are two types thread, one is static thread, the another is runonce thread.\r\n2. **Static threads** can referened by `tthread::THREAD_ID`. You can get it everywhere during whole lifecycle by `tthread::THREAD_ID`.\r\n3. **Runonce threads** just run one task every time. You can never insure that the runonce thread you get this time is the one you have got last time. \r\n4. All runonce threads managed in a thread pool. The threads in sleep state will be reused next time.\r\n\r\n### `tthread::AsyncMessage()`\r\n[Integrate with UI thread](#Integrate with UI thread) has mentioned that you can send message to trigger callback function in UI thread. Except that, you also can send message to task thread. It is depending on the type of callback object. See [Asynchronous callback](#Asynchronous callback).\r\nSample:\r\n```cpp\r\nclass UserMsgCallback : public tthread::IAsyncRunnableMsgCallback\r\n{\r\n\tvoid OnAsyncComplete(ScopedRefPtr<ReturnValue> ret, const tstring& identifier)\r\n\t{\r\n\t\t// some logic\r\n\t}\r\n}\r\n\r\n// some logic\r\n\r\nUserMsgCallback user_msg_callback; // in UI thread(main thread)\r\n\r\n// some logic\r\n\r\ntthread::ReturnValue* msg = new tthread::ReturnValue;\r\nmsg.default_ret_ = 123;\r\ntthread::AsyncMessage(_T(\"this_is_a_msg\"), msg, &user_msg_callback);\r\n```\r\n```cpp\r\nclass UserTaskCallback : public tthread::IAsyncRunnableTaskCallback\r\n{\r\n\tvoid OnAsyncComplete(ScopedRefPtr<ReturnValue> ret, const tstring& identifier)\r\n\t{\r\n\t\t// some logic\r\n\t}\r\n}\r\n\r\n// some logic\r\n\r\ntthread::ScopedRefPtr<UserTaskCallback> user_task_callback = new UserTaskCallback;\r\n\r\n// some logic\r\n\r\ntthread::ReturnValue* msg = new tthread::ReturnValue;\r\nmsg.default_ret_ = 123;\r\ntthread::AsyncMessage(_T(\"this_is_a_msg\"), msg, user_task_callback.get(), tthread::USER_DEF);\r\n```\r\n**Do not** delete message by yourself. It will be recycled automatically.\r\n\r\nAgain, as said in [Asynchronous callback](#Aysnchronous callback), `tthread::AsyncRunnableMsgCallback` **does not** support smart pointer, you should manage lifecycle of callback objcet and make sure it is exist when callback function is called.\r\n\r\n### `tthread::SyncTask()`\r\nIf you want to run task in other thread then wait for it in invoke thread, you should use this interface. When task finishes, `tthread::SyncTask()` will return `tthread::ScopedRefPtr<tthread::ReturnValue>` object directly.\r\n\r\n### Quit\r\n* There are two interfaces for quit: `tthread::SafeQuit()` and `tthread::SafeEmergencyQuit()`.\r\n* Once you invoke one of two, you **can not** send tasks to the task queue managed by IOCP.\r\n* `tthread::SafeQuit()` quit all threads after all tasks in queue have been run.\r\n* `tthread::SafeEmergencyQuit()` quit all threads without running tasks in queue.\r\n\r\n## Common use elements\r\nDetails about these elements, please read source code.\r\n### Header\r\n`src/task_thread_export.h`\r\n\r\n### Namespace\r\n`tthread`\r\n\r\n### Function\r\n```cpp\r\ntthread::Bind()\r\n\r\ntthread::AsyncTask()\r\n\r\ntemplate <typename ReturnValueType>\r\ntthread::AsyncTask<ReturnValueType>()\r\n   \r\ntthread::AsyncMessage()\r\n\r\ntthread::SyncTask()\r\n\r\ntemplate <typename ReturnValueType>\r\ntthread::SyncTask<ReturnValueType>()\r\n```   \r\n### Base Class\r\n```cpp\r\ntthread::ReturnValue\r\n\r\ntthread::ReturnParam\r\n\r\ntthread::IAsyncRunnableCallbackBase\r\n\r\ntthread::IAsyncRunnableMsgCallback\r\n\r\ntthread::IAsyncRunnableTaskCallback\r\n```\r\n### Enum\r\n```cpp\r\ntthread::THREAD_ID\r\n```\r\n### Utils\r\n```cpp\r\ntthread::RefCountedThreadSafe\r\n\r\ntthread::StringReturnValue\r\n\r\ntthread::IntReturnValue\r\n\r\ntthread::ScopedRefPtr\r\n\r\ntthread::ScopedPtr\r\n\r\ntemplate <typename T>\r\ntthread::Unretained()\r\n\r\ntemplate <typename T>\r\ntthread::ConstRef()\r\n\r\ntemplate <typename T>\r\ntthread::IgnoreResult()\r\n```\r\n# Demo\r\nSee demo project.\r\n\r\n# Feedback\r\nSend mail to <tiankk@gmail.com>.\r\n\r\n# License\r\nMIT\r\n","google":"UA-48348102-1","note":"Don't delete this file! It's used internally to help with page regeneration."}